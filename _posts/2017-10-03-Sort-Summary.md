---
layout: post
title: 经典排序算法归纳
---

### 1.比较排序算法
####  **（1）插入排序**
**基本思想：** 将一个记录插入到已排序好的有序表中，从而得到一个新的，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。

**稳定性：** 插入排序是稳定的————如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是**稳定的**。 

**复杂度分析：** 时间复杂度为O(n<sup>2</sup>),最好的情况是已经排好序的，此时时间复杂度为O(N),最坏情况为逆序情况时，此时时间复杂度为O(n<sup>2</sup>)。

**算法实现：**

    void insert_sort(int* a, int size){
	    for (int j = 1; j < size; j++){
		    int key = a[j];
		    int i = j - 1;
		    //在已经排好序的数组的前半部分中，若是比当前插入的值大，则往后
		    //移直到找到一个值比当前值小或者下标值小于0，则结束循环	
		    while (i >= 0 && a[i]>key){
			    a[i + 1] = a[i];
			    i--;
		    }	
	    	a[i+1] = key;
        }
    }
  
  
  
 
#### **（2）选择排序**
**基本思想：** 在要排序的一组数中，选出最小（或者最大）的一个数与第一个位置的数交换，然后在剩下的数中再找最小（或者最大）的与第二个位置的数交换，依此类推，直到第n-1个元素和第n个元素比较为止。

**操作方法：** 
第一趟，从n 个记录中找出关键码最小的记录与第一个记录交换；
第二趟，从第二个记录开始的n-1 个记录中再选出关键码最小的记录与第二个记录交换；
以此类推.....
第i 趟，则从第i 个记录开始的n-i+1 个记录中选出关键码最小的记录与第i 个记录交换，
直到整个序列按关键码有序。

**稳定性：**选择排序是**不稳定**的。例如：在某一趟交换选择中，该趟的第一个元素与最小元素之间有一个与第一元素相等的值，则会导致第一个元素与最小元素交换之后，两个相等的元素中，原本位于前面的那个元素移动到后面去了，例如：5，8，5，2，9。经过选择交换之后，两个值为5的元素相对位置就会改变。

**复杂度分析：** 选择排序的时间复杂度为O(n<sup>2</sup>)。因为每趟都要选出剩下部分的最小值，所以最好和最坏的时间复杂度均为O(n<sup>2</sup>)。

**算法实现：**

    void select_sort(int* a, int size){
	    for (int i = 0; i < size; i++){
		    int min = a[i];
		    int k = i;
		    for (int j = i + 1; j < size; j++){
		    	if (a[j] < min){
			    	min = a[j];
			    	k = j;
			    }
		    }
	   	    swap(a[i], a[k]);
	    }
	}
	
#### **（3）冒泡排序**
**基本思想：**在要排序的一组数中，对*当前还未排好序的范围内的全部数*，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。

**稳定性：**冒泡排序是**稳定**的。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。

**复杂度分析：** 冒泡排序的时间复杂度为O(n<sup>2</sup>)。

**算法实现：**

    void bulble_sort(int* a, int size){
	    for (int i = 0; i < size - 1; i++){//总共要比较size-1趟
		    for (int j = 0; j < size - 1 -i; j++)
		    {//注意这里的写法，因为每趟交换之后，最大的那个数将会沉到最后
		    	if (a[j] > a[j + 1]){
			    	swap(a[j], a[j + 1]);
		    	}			
		    }
		    print(a, size);
	    }
	}

#### **（5）快速排序**
**算法步骤：**
1. 从数列中挑出一个元素，称为“基准”（pivot）。
2. 重新排序序列，所有比基准值小的元素摆在基准的前面，所有比基准大的元素摆在基准的后面（和基准相同的数可以摆在任意一边）。在这个分区退出后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子序列排序。递归基是当子序列只有一个元素时，这时就已经排序好了。