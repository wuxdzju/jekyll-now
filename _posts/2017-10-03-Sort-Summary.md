---
layout: post
title: 经典排序算法归纳
---

### 1.比较排序算法
####  **（1）插入排序**
**基本思想：** 将一个记录插入到已排序好的有序表中，从而得到一个新的，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。

**稳定性：** 插入排序是稳定的————如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是**稳定的**。 

**复杂度分析：** 时间复杂度为O(n<sup>2</sup>),最好的情况是已经排好序的，此时时间复杂度为O(N),最坏情况为逆序情况时，此时时间复杂度为O(n<sup>2</sup>)。

**算法实现：**

    void insert_sort(int* a, int size){
	    for (int j = 1; j < size; j++){
		    int key = a[j];
		    int i = j - 1;
		    //在已经排好序的数组的前半部分中，若是比当前插入的值大，则往后
		    //移直到找到一个值比当前值小或者下标值小于0，则结束循环	
		    while (i >= 0 && a[i]>key){
			    a[i + 1] = a[i];
			    i--;
		    }	
	    	a[i+1] = key;
        }
    }
  

----------

#### **（2）选择排序**
**基本思想：** 在要排序的一组数中，选出最小（或者最大）的一个数与第一个位置的数交换，然后在剩下的数中再找最小（或者最大）的与第二个位置的数交换，依此类推，直到第n-1个元素和第n个元素比较为止。

**操作方法：** 
第一趟，从n 个记录中找出关键码最小的记录与第一个记录交换；
第二趟，从第二个记录开始的n-1 个记录中再选出关键码最小的记录与第二个记录交换；
以此类推.....
第i 趟，则从第i 个记录开始的n-i+1 个记录中选出关键码最小的记录与第i 个记录交换，
直到整个序列按关键码有序。

**稳定性：**选择排序是**不稳定**的。例如：在某一趟交换选择中，该趟的第一个元素与最小元素之间有一个与第一元素相等的值，则会导致第一个元素与最小元素交换之后，两个相等的元素中，原本位于前面的那个元素移动到后面去了，例如：5，8，5，2，9。经过选择交换之后，两个值为5的元素相对位置就会改变。

**复杂度分析：** 选择排序的时间复杂度为O(n<sup>2</sup>)。因为每趟都要选出剩下部分的最小值，所以最好和最坏的时间复杂度均为O(n<sup>2</sup>)。

**算法实现：**

    void select_sort(int* a, int size){
	    for (int i = 0; i < size; i++){
		    int min = a[i];
		    int k = i;
		    for (int j = i + 1; j < size; j++){
		    	if (a[j] < min){
			    	min = a[j];
			    	k = j;
			    }
		    }
	   	    swap(a[i], a[k]);
	    }
	}


----------


	
#### **（3）冒泡排序**
**基本思想：**在要排序的一组数中，对*当前还未排好序的范围内的全部数*，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。

**稳定性：**冒泡排序是**稳定**的。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。

**复杂度分析：** 冒泡排序的时间复杂度为O(n<sup>2</sup>)。

**算法实现：**

    void bulble_sort(int* a, int size){
	    for (int i = 0; i < size - 1; i++){//总共要比较size-1趟
		    for (int j = 0; j < size - 1 -i; j++)
		    {//注意这里的写法，因为每趟交换之后，最大的那个数将会沉到最后
		    	if (a[j] > a[j + 1]){
			    	swap(a[j], a[j + 1]);
		    	}			
		    }
	    }
	}


----------


#### **（4）归并排序**
**基本思想：**分治法（Divive and Conquer）：将元问题划分成n个规模较小而结构与原问题相似的子问题，
递归地解决这些子问题，然后再合并其结果，就得到原问题的解。
归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素（认为直接有序），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。

**操作方法：** 
分解：将n个元素分成各含n/2个元素的组序列。
解决：用归并排序的方法对两个子序列递归地排序。
合并：合并两个已经排好序的子序列以得到排序结果。

**稳定性：**元素的交换发生在短的有序序列合并的过程中，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是**稳定的**排序算法。

**复杂度分析：**首先考虑下如何将将二个有序数列合并。这个非常简单，只要从比较二个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。这需要将待排序序列中的所有记录扫描一遍，因此耗费O(n)时间，而由完全二叉树的深度可知，整个归并排序需要进行.logn.次，因此，总的**时间复杂度**为O(nlogn)。
归并排序需要额外的空间存储临时数组，**空间复杂度**为O(n)。

**算法实现：**

    void merge(int *a, int p, int m, int q){
	    int la = m - p;
	    int *tmp_a = new int[la];//合并时，前半部分一定要放在另一个临时数组中
	    for (int i = 0; i < la; i++)
		    tmp_a[i] = a[p+i];//注意数组a的起始地址为p而不是0啊啊啊啊
	    int lb = q - m;
	    int *tmp_b = a+m;//后半部分可以占用原来的空间，也可以另辟一个新的数组空间
	    for (int i = 0, j = 0, k = p; i < la || j < lb;){//注意数组a的起始地址为p而不是0啊啊啊啊
		    if (i < la && (j >= lb || tmp_a[i] <=tmp_b[j])){
		        //tmp_a没有越界，并且tmp_a当前值比tmp_b的当前值要小，
		        //注意哨兵位置的应用，此时若b越界，则看成无穷大，故此时也是tmp_a的值要小
			    a[k++] = tmp_a[i++];			
	    	}	
		    else if (j < lb && (i >= la || tmp_b[j] < tmp_a[i])){
			    a[k++] = tmp_b[j++];			
		    }
	    }
	}

    void merge_sort(int *a, int p,int q){
	    if (q-p<=1) return;//递归基，当只有一个元素时，已经排好了序
	    int mid = (p + q) / 2;
	    merge_sort(a, p, mid);
	    merge_sort(a, mid, q);
	    merge(a, p, mid, q);
    }
  


----------
#### **（5）快速排序**
**基本思想：**
1. 从数列中挑出一个元素，称为“基准”（pivot）。
2. 重新排序序列，所有比基准值小的元素摆在基准的前面，所有比基准大的元素摆在基准的后面（和基准相同的数可以摆在任意一边）。在这个分区退出后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子序列排序。递归基是当子序列只有一个元素时，这时就已经排序好了。

**数组划分：**
![_config.yml]({{ site.baseurl }}/images/quick-sort.png)

**稳定性：** 快速排序的交换方式决定其是一个**不稳定**的排序算法。以5，7，5，7，6为例，每趟交换都以最后一个元素作基准，则最后的结果会使得两个值为7的元素位置交换。

**复杂度分析：** 快速排序期望运行的时间为O(nlgn)，且O(nlgn)记号中隐含的常数因子很小，且还能够进行**就地排序**，快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。
但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。此时，最坏情况下时间复杂度为O(n<sup>2</sup>)。

**算法实现：**

    int partition(int *a, int p, int q){
	    int x = a[q];//以最后一个元素为基准
	    int i = p - 1;
	    for (int j = p; j < q; j++){//从第一个元素到倒数第二个元素
		    if (a[j] <= x){
		    	i++;
			    swap(a[i], a[j]);
		    }
	    }
	    swap(a[i + 1], a[q]);
	    return i + 1;
    }
    
    void quick_sort(int *a, int p, int q){//闭区间
	    if (p < q){
		    int m = partition(a, p, q);
		    quick_sort(a, p, m - 1);
	    	quick_sort(a, m + 1, q);
	    }	
	}

**快速排序的改进——快速排序的随机化版本**
在这种方法中，不是始终采用A[r]作为主元（pivot），其中r为最末尾的那个元素，而是从字数组A[p,,r]中随机选择一个元素，即将A[r]与从A[r]中随机选出的那个元素交换。这么做确保了在子数组中r-p+1个元素中，主元素A[r]等可能取其中的任何一个。因为主元素是随机选择的，我么期望在平均情况下，对输入数组的划分能比较对称。
算法实现：

    int rand_partition(int *a, int p, int q){
	    srand((unsigned)time(NULL));
    	int k = p + rand() % (q - p + 1);
	    swap(a[k], a[q]);
	    int x = a[q];
	    int i = p - 1;
	    for (int j = p; j < q; j++){
		    if (a[j] <= x){
		    	i++;
		        swap(a[i], a[j]);
		    }
    	}
	    swap(a[i + 1], a[q]);
	    return i + 1;
    }
    
    void rand_quick_sort(int *a, int p, int q){
	    if (p < q){
		    int m = rand_partition(a, p, q);
	    	rand_quick_sort(a, p, m-1);
		    rand_quick_sort(a, m + 1, q);
	    }
	}


此外，还有很多快速排序的改进方法，例如常采用的“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。


----------


#### **（6）堆排序**
**基本思想：** 堆排序是把数组看作堆，第i个结点的孩子结点为第2*i+1和2*i+2个结点（不超出数组长度前提下），堆排序的第一步是建堆，然后是取堆顶元素然后调整堆。建堆的过程是自底向上不断调整达成的，这样当调整某个结点时，其左节点和右结点已经是满足条件的，此时如果两个子结点不需要动，则整个子树不需要动，如果调整，则父结点交换到子结点位置，再以此结点继续调整。下述代码使用的大顶堆，建立好堆后堆顶元素为最大值，此时取堆顶元素即使堆顶元素和最后一个元素交换，最大的元素处于数组最后，此时调整小了一个长度的堆，然后再取堆顶和倒数第二个元素交换，依次类推，完成数据的非递减排序。

**稳定性：** 我们知道堆的结构是节点i的孩子为2*i+1和2*i+2节点**（起始节点为0）**，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第（n-1）/2开始和其子节点共3个值选择最大（大顶堆）或者最小（小顶堆），这3个元素之间的选择当然不会破坏稳定性。但当为（n-1）/2-1， （n-1）/2- 2， ... 1这些个父节点选择元素时，就会破坏稳定性。有可能第（n-1）/2个父节点交换把后面一个元素交换过去了，而第（n-1）/2 - 1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序是**不稳定**的排序算法。

**复杂度分析：** 保持堆性质的函数需要log(n)的时间复杂度，堆排序的过程，需要进行n-1交换堆顶元素，因此需要进行n-1次堆序性维护，因此堆排序的时间复杂度为nlog(n)。
堆排序是一种**原地排序**算法，不需要额外的空间。

**算法实现：**
    
    //这个函数是对最大堆进行操作的重要的子程序。我们假定left(i)和right(i)为根的两颗二叉树都是最大堆
    //但这时a[i]可能小于其子女，这样违反了最大堆，该程序让a[i]下降，使以i为根的子树成为最大堆
    void max_heapify(int *a, int i, int heapsize){
	    int l = 2 * i + 1;
	    int r = 2 * i + 2;
	    int largest = i;
	    if (l<heapsize && a[l]>a[largest])
	    	largest = l;
	    if (r<heapsize && a[r]>a[largest])
	    	largest = r;
	    if (largest != i){
	    	swap(a[i], a[largest]);
		    max_heapify(a, largest, heapsize);
    	}
    }
    
    //从第一个非叶子节点开始，自底向上建堆
    void build_heap(int *a, int heapsize){
	    for (int i = (heapsize - 2) / 2; i >= 0; i--){
		    max_heapify(a, i, heapsize);
	    }
	}
	
	void heap_sort(int *a, int size){
	    int heapsize = size;
	    build_heap(a, heapsize);//建堆
	    while(heapsize>1){
	    	swap(a[0], a[heapsize-1]);//将当前堆顶元素与堆的最后一个元素交换
	    	heapsize--;
	    	max_heapify(a, 0, heapsize);
	    }
    }

	


----------
### 2.线性时间排序算法
**（1）计数排序算法**
计数排序假设n个输入元素中的每一个都是介于0到k之间的整数，此处k为缪戈整数。k=O(n)时，计数排序的运行时间为O(n)。计数排序是一种非常快捷的**稳定性强**的排序方法，时间复杂度O(n+k),其中n为要排序的数的个数，k为要排序的数的组大值。计数排序对一定量的整数排序时候的速度非常快，一般快于其他排序算法。但计数排序**局限性比较大**，只限于对整数进行排序。计数排序是消耗空间发杂度来获取快捷的排序方法，其空间发展度为O（K）同理K为要排序的最大值。

**基本思想：** 对每个输入元素x，确定出小于x的元素个数。有了这一信息，就可以把x直接放到它在最终输出数组中的位置上。例如要排序的数为 7 4 2 1 5 3 1 5；则比7小的有7个数，所有7应该在排序好的数列的第八位，同理3在第四位，对于重复的数字，1在1位和2位（暂且认为第一个1比第二个1小），5和1一样位于6位和7位。

**稳定性：** 计数排序是**稳定的**。对于重复的数，每排好一个数则对其位置数进行减减操作，以此对完成其余相同的数字进行排位。因为操作是从前往后的，保证了两个数值相同的数原来位于后面的，经过计数排序后还是位于后面，因此保证了**稳定性**。

**复杂度分析：** 时间复杂度为O(n+k)，空间复杂度为O(n+k)。

**算法思路：** 
1. 扫描序列A，以A中的每个元素的值为索引，把出现的个数填入C中。此时C[i]可以表示A中值为i的元素的个数。
2. 对于C从头开始累加，使C[i]<-C[i]+C[i-1]。这样，C[i]就表示A中值不大于i的元素的个数。
3. 按照统计出的值，输出结果。

**算法实现：**
	

    void count_sort(int *a, int *b, int size, int k){//a为输入数组，b为输出数组，size为数组大小，数组中元素的值为[0,k]之间
	    int *c = new int[k + 1];//临时数组，用来记录当前值为k的元素应放的位置
    	for (int i = 0; i < k + 1; i++)
	    	c[i] = 0;
	    for (int i = 0; i < size; i++)
	    	c[a[i]]++;
	    for (int i = 1; i < k + 1; i++)
	    	c[i] = c[i] + c[i - 1];
    	for (int i = size - 1; i >= 0; i--){//从后往前，将值为a[i]的元素放置在正确的位置,保证了排序算法的稳定性
	    	b[c[a[i]]-1] = a[i];//注意左边的下标要减一
	    	c[a[i]]--;//每当将值为a[i]的元素放置在数组b中时，都要减小c[a[i]]的值，这会使得下一个值为a[i]的元素
	    	           //（如果存在的话，直接放置在数组a[i]原位置的前一个位置）
	    }
    	delete [] c;
    }








**【参考】**
[八大排序算法](http://blog.csdn.net/hguisu/article/details/7776068) |
[各种排序算法总结和比较](https://www.cnblogs.com/zhaoshuai1215/p/3448154.html) |
[稳定排序和不稳定排序](https://www.cnblogs.com/codingmylife/archive/2012/10/21/2732980.html)|
[三种线性排序算法 计数排序、桶排序与基数排序](https://www.byvoid.com/zhs/blog/sort-radix)|