---
layout: post
title: 经典排序算法归纳
---

### 1.比较排序算法
####  **（1）插入排序**
**基本思想：** 将一个记录插入到已排序好的有序表中，从而得到一个新的，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。

**稳定性：** 插入排序是稳定的————如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是**稳定的**。 

**复杂度分析：** 时间复杂度为O(n<sup>2</sup>),最好的情况是已经排好序的，此时时间复杂度为O(N),最坏情况为逆序情况时，此时时间复杂度为O(n<sup>2</sup>)。

**算法实现：**

    void insert_sort(int* a, int size){
	    for (int j = 1; j < size; j++){
		    int key = a[j];
		    int i = j - 1;
		    //在已经排好序的数组的前半部分中，若是比当前插入的值大，则往后
		    //移直到找到一个值比当前值小或者下标值小于0，则结束循环	
		    while (i >= 0 && a[i]>key){
			    a[i + 1] = a[i];
			    i--;
		    }	
	    	a[i+1] = key;
        }
    }
  
  
  
 
#### **（2）选择排序**
**基本思想：** 在要排序的一组数中，选出最小（或者最大）的一个数与第一个位置的数交换，然后在剩下的数中再找最小（或者最大）的与第二个位置的数交换，依此类推，直到第n-1个元素和第n个元素比较为止。

**操作方法：** 
第一趟，从n 个记录中找出关键码最小的记录与第一个记录交换；
第二趟，从第二个记录开始的n-1 个记录中再选出关键码最小的记录与第二个记录交换；
以此类推.....
第i 趟，则从第i 个记录开始的n-i+1 个记录中选出关键码最小的记录与第i 个记录交换，
直到整个序列按关键码有序。

**稳定性：**选择排序是**不稳定**的。例如：在某一趟交换选择中，该趟的第一个元素与最小元素之间有一个与第一元素相等的值，则会导致第一个元素与最小元素交换之后，两个相等的元素中，原本位于前面的那个元素移动到后面去了，例如：5，8，5，2，9。经过选择交换之后，两个值为5的元素相对位置就会改变。

**复杂度分析：** 选择排序的时间复杂度为O(n<sup>2</sup>)。因为每趟都要选出剩下部分的最小值，所以最好和最坏的时间复杂度均为O(n<sup>2</sup>)。

**算法实现：**

    void select_sort(int* a, int size){
	    for (int i = 0; i < size; i++){
		    int min = a[i];
		    int k = i;
		    for (int j = i + 1; j < size; j++){
		    	if (a[j] < min){
			    	min = a[j];
			    	k = j;
			    }
		    }
	   	    swap(a[i], a[k]);
	    }
	}
	
#### **（3）冒泡排序**
**基本思想：**在要排序的一组数中，对*当前还未排好序的范围内的全部数*，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。

**稳定性：**冒泡排序是**稳定**的。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。

**复杂度分析：** 冒泡排序的时间复杂度为O(n<sup>2</sup>)。

**算法实现：**

    void bulble_sort(int* a, int size){
	    for (int i = 0; i < size - 1; i++){//总共要比较size-1趟
		    for (int j = 0; j < size - 1 -i; j++)
		    {//注意这里的写法，因为每趟交换之后，最大的那个数将会沉到最后
		    	if (a[j] > a[j + 1]){
			    	swap(a[j], a[j + 1]);
		    	}			
		    }
		    print(a, size);
	    }
	}


#### **（4）归并排序**
**基本思想：**分治法（Divive and Conquer）：将元问题划分成n个规模较小而结构与原问题相似的子问题，
递归地解决这些子问题，然后再合并其结果，就得到原问题的解。
归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素（认为直接有序），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。

**操作方法：** 
分解：将n个元素分成各含n/2个元素的组序列。
解决：用归并排序的方法对两个子序列递归地排序。
合并：合并两个已经排好序的子序列以得到排序结果。

**稳定性：**元素的交换发生在短的有序序列合并的过程中，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是**稳定的**排序算法。

**复杂度分析：**首先考虑下如何将将二个有序数列合并。这个非常简单，只要从比较二个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。这需要将待排序序列中的所有记录扫描一遍，因此耗费O(n)时间，而由完全二叉树的深度可知，整个归并排序需要进行.logn.次，因此，总的**时间复杂度**为O(nlogn)。
归并排序需要额外的空间存储临时数组，**空间复杂度**为O(n)。

**算法实现：**

    void merge(int *a, int p, int m, int q){
	    int la = m - p;
	    int *tmp_a = new int[la];//合并时，前半部分一定要放在另一个临时数组中
	    for (int i = 0; i < la; i++)
		    tmp_a[i] = a[p+i];//注意数组a的起始地址为p而不是0啊啊啊啊
	    int lb = q - m;
	    int *tmp_b = a+m;//后半部分可以占用原来的空间，也可以另辟一个新的数组空间
	    for (int i = 0, j = 0, k = p; i < la || j < lb;){//注意数组a的起始地址为p而不是0啊啊啊啊
		    if (i < la && (j >= lb || tmp_a[i] <=tmp_b[j])){
		        //tmp_a没有越界，并且tmp_a当前值比tmp_b的当前值要小，
		        //注意哨兵位置的应用，此时若b越界，则看成无穷大，故此时也是tmp_a的值要小
			    a[k++] = tmp_a[i++];			
	    	}	
		    else if (j < lb && (i >= la || tmp_b[j] < tmp_a[i])){
			    a[k++] = tmp_b[j++];			
		    }
	    }
	}

    void merge_sort(int *a, int p,int q){
	    if (q-p<=1) return;//递归基，当只有一个元素时，已经排好了序
	    int mid = (p + q) / 2;
	    merge_sort(a, p, mid);
	    merge_sort(a, mid, q);
	    merge(a, p, mid, q);
    }
  


----------
#### **（5）快速排序**
**基本思想：**
1. 从数列中挑出一个元素，称为“基准”（pivot）。
2. 重新排序序列，所有比基准值小的元素摆在基准的前面，所有比基准大的元素摆在基准的后面（和基准相同的数可以摆在任意一边）。在这个分区退出后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子序列排序。递归基是当子序列只有一个元素时，这时就已经排序好了。

**数组划分：**
![_config.yml]({{ site.baseurl }}/images/quick-sort.png)

**稳定性：** 快速排序的交换方式决定其是一个**不稳定**的排序算法。以5，7，5，7，6为例，每趟交换都以最后一个元素作基准，则最后的结果会使得两个值为7的元素位置交换。

**复杂度分析：** 快速排序期望运行的时间为O(nlgn)，且O(nlgn)记号中隐含的常数因子很小，且还能够进行**就地排序**，快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。
但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。此时，最坏情况下时间复杂度为O(n<sup>2</sup>)。

**算法实现：**

    int partition(int *a, int p, int q){
	    int x = a[q];//以最后一个元素为基准
	    int i = p - 1;
	    for (int j = p; j < q; j++){//从第一个元素到倒数第二个元素
		    if (a[j] <= x){
		    	i++;
			    swap(a[i], a[j]);
		    }
	    }
	    swap(a[i + 1], a[q]);
	    return i + 1;
    }
    
    void quick_sort(int *a, int p, int q){//闭区间
	    if (p < q){
		    int m = partition(a, p, q);
		    quick_sort(a, p, m - 1);
	    	quick_sort(a, m + 1, q);
	    }	
	}



