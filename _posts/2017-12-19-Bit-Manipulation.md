---
layout: post
title: 位运算简介及使用技巧【转】
---

## 一、位运算基础
转自[位运算简介及实用技巧（一）：基础篇](http://www.matrix67.com/blog/archives/263)

**注意：**一些值得注意的点
**1** 当进行位运算时，一个值得注意的概念是数值1并不是一个bit位，例如在32位int型中，1表示二进制表示为00000000 00000000 00000000 00000001.
**2** 注意左移<< 右移>> 的运算符优先级要低于加减法。
**3**  and(与)运算通常用于二进制取位操作，例如一个数 and 1的结果就是取二进制的最末位。这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数为偶数，最末位为1表示该数为奇数.
**4** or（或）运算通常用于二进制特定位上的无条件赋值，例如一个数or 1的结果就是把二进制最末位强行变成1。如果需要把二进制最末位变成0，对这个数or 1之后再减一就可以了，其实际意义就是把这个数强行变成最接近的偶数。
**5** xor运算通常用于对二进制的特定一位进行取反操作，因为异或可以这样定义：0和1异或0都不变，异或1则取反。
    xor运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即(a xor b) xor b = a。xor运算可以用于简单的加密。
    
**位运算的简单应用**

```
  功能              |           示例            |    位运算
———————-+—————————+——————–
去掉最后一位          | (101101->10110)           | x shr 1
在最后加一个0         | (101101->1011010)         | x shl 1
在最后加一个1         | (101101->1011011)         | x shl 1+1
把最后一位变成1       | (101100->101101)          | x or 1
把最后一位变成0       | (101101->101100)          | x or 1-1
最后一位取反          | (101101->101100)          | x xor 1
把右数第k位变成1      | (101001->101101,k=3)      | x or (1 shl (k-1))
把右数第k位变成0      | (101101->101001,k=3)      | x and not (1 shl (k-1))
右数第k位取反         | (101001->101101,k=3)      | x xor (1 shl (k-1))
取末三位              | (1101101->101)            | x and 7
取末k位               | (1101101->1101,k=5)       | x and (1 shl k-1)
取右数第k位           | (1101101->1,k=4)          | x shr (k-1) and 1
把末k位变成1          | (101001->101111,k=4)      | x or (1 shl k-1)
末k位取反             | (101001->100110,k=4)      | x xor (1 shl k-1)
把右边连续的1变成0    | (100101111->100100000)    | x and (x+1)
把右起第一个0变成1    | (100101111->100111111)    | x or (x+1)
把右边连续的0变成1    | (11011000->11011111)      | x or (x-1)
取右边连续的1         | (100101111->1111)         | (x xor (x+1)) shr 1
去掉右起第一个1的左边 | (100101000->1000)         | x and (x xor (x-1))
```
**c++代码**
```c++
#include<iostream>
#include<bitset>
using namespace std;

int main(){
	int a = 44;
	cout << "十进制:" << a << endl;
	cout << "十六进制:" << hex << a << endl;
	cout << "八进制:" << oct << a << endl;
	cout << "二进制:" << bitset<8>(a) << endl;
	cout << "去掉最后一位：" << bitset<8>(a >> 1) << endl;
	cout << "在最后加一个0：" << bitset<8>(a << 1) << endl;
	cout << "在最后加一个1：" << bitset<8>((a << 1) + 1) << endl;//左移、右移的优先级要小于加减法的优先级
	cout << "把最后一位变成1：" << bitset<8>(a | 1) << endl;
	cout << "提取最后一位：" << bitset<8>(a & 1) << endl;
	cout << "把最后一位变成0：" << bitset<8>((a | 1) - 1) << endl;
	cout << "把最后一位取反：" << bitset<8>(a ^ 1) << endl;
	int k = 4;
	cout << "把右数第" << k << "位变成1：" << bitset<8>(a | (1 << (k - 1))) << endl;
	cout << "把右数第" << k << "位变成0：" << bitset<8>((a | (1 << (k - 1)) )- 1)<<endl;
	cout << "把右数第" << k << "取反：" << bitset<8>(a ^(1<<(k-1))) << endl;
	cout << "取末位" << 3 << "位:" << bitset<8>(a & 7) << endl;
	cout << "取末位" << k << "位:" << bitset<8>(a & ((1<<k)-1)) << endl;
	cout << "取右数第" << k << "位:" << bitset<8>((a >> (k - 1)) & 1) << endl;	
	cout << "把末" << k << "位变成1：" << bitset<8>(a | ((1 << k) - 1)) << endl;
	cout << "把末" << k << "位按位取反：" << bitset<8>(a ^ ((1 << k) - 1)) << endl;
	cout << "把右边连续的1变成0：" << bitset<8>(a & (a + 1)) << endl;
	cout << "把右起第一个0变成1：" << bitset<8>(a | (a + 1)) << endl;
	cout << "把右边连续的0变成1：" << bitset<8>(a | (a - 1)) << endl;
	cout << "取右边连续的1:" << bitset<8>((a ^ (a + 1)) >> 1) << endl;
	cout << "去掉右起第一个1的左边：" << bitset<8>(a&(a ^ (a - 1))) << endl;
}
```
