---
layout: post
title: 位运算简介及使用技巧【转】
---

[TOC]

## 一、计算机原码、反码、补码
【转】[计算机原码、反码、补码详解][http://blog.csdn.net/u011080472/article/details/51280919](http://blog.csdn.net/u011080472/article/details/51280919)

### **1、机器数与真值**
**机器数**

一个数在计算机中的二进制表示形式叫做这个数的机器数，机器数是带符号的，在计算机中用一个数的最高位存放符号，正数为0，负数为1.

比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。那么，这里的 00000011 和 10000011 就是机器数。

**真值** 

因为第一位是符号位，所以机器数的形式值并不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，**将带符号位的机器数对应的真正数值称为机器数的真值**。

### **2、原码、反码、补码**
**原码**
原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值，
比如如果是8位二进制:

[+1]原 = 0000 0001

[-1]原 = 1000 0001

第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:

[1111 1111 , 0111 1111]，即：

[-127 , 127]

原码是人脑最容易理解和计算的表示方式。

**反码** 
反码的表示方式是：正数的反码是其本身，负数的反码是在其源码的基础上，符号位不变，其余各个位取反。

[+1] = [00000001]原 = [00000001]反

[-1] = [10000001]原 = [11111110]反

可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值，通常要将其转换成原码再计算。

**补码**
补码的表示方式是：正数的补码就是其本身；而负数的补码是在其反码的基础上+1.

[+1] = [00000001]原 = [00000001]反 = [00000001]补

[-1] = [10000001]原 = [11111110]反 = [11111111]补

对于负数，补码的表示方式也是人脑无法直观看出其数值的。通常也需要转换成原码再计算其数值。

### **3、为何要使用原码。反码和补码**

在开始深入学习前, 我的学习建议是先”死记硬背”上面的原码, 反码和补码的表示方式以及计算方法.

现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:

[+1] = [00000001]原 = [00000001]反 = [00000001]补

所以不需要过多解释. 但是对于负数:

[-1] = [10000001]原 = [11111110]反 = [11111111]补

可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?

首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.

于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码。计算十进制的表达式: 1-1=0

1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2

如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.

为了解决原码做减法的问题, 出现了反码。计算十进制的表达式:

1-1=0

1 - 1 = 1 + (-1) 
= [0000 0001]原 + [1000 0001]原 
= [0000 0001]反 + [1111 1110]反 
= [1111 1111]反 = [1000 0000]原 
= -0

**发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在”0”这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.**

**于是补码的出现, 解决了0的符号以及两个编码的问题**:

1-1 = 1 + (-1) 
= [0000 0001]原 + [1000 0001]原 
= [0000 0001]补 + [1111 1111]补 
= [0000 0000]补=[0000 0000]原

这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:

(-1) + (-127) = [1000 0001]原 + [1111 1111]原 
= [1111 1111]补 + [1000 0001]补 
= [1000 0000]补

**-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的原码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)**

**使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].**

**因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-2^31, 2^31-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值.**




## 二、位运算基础
转自[位运算简介及实用技巧（一）：基础篇](http://www.matrix67.com/blog/archives/263)

**注意：** 一些值得注意的点

**1** 当进行位运算时，一个值得注意的概念是数值1并不是一个bit位，例如在32位int型中，1表示二进制表示为00000000 00000000 00000000 00000001.

**2** 注意左移<< 右移>> 的运算符优先级要低于加减法。

**3**  and(与)运算通常用于二进制取位操作，例如一个数 and 1的结果就是取二进制的最末位。这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数为偶数，最末位为1表示该数为奇数.

**4** or（或）运算通常用于二进制特定位上的无条件赋值，例如一个数or 1的结果就是把二进制最末位强行变成1。如果需要把二进制最末位变成0，对这个数or 1之后再减一就可以了，其实际意义就是把这个数强行变成最接近的偶数。

**5** xor运算通常用于对二进制的特定一位进行取反操作，因为异或可以这样定义：0和1异或0都不变，异或1则取反。
    xor运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即(a xor b) xor b = a。xor运算可以用于简单的加密。
    
**6、关于左移运算与右移运算：**
左移运算符m<<n表示把m左移n位。左移n位的时候，最左边的n位将被丢弃，同时在最右边补上n个0

例：
00001010<<2 = 00101000

右移运算符m>>n表示把m右移n位。右移n位的时候，最右边的n位将被丢弃。但右移时处理最左边位的情形要稍微复杂一些。如果数字是一个无符号数值，则用0补全最左边的n位。如果数字是一个有符号数值，则用数字的符号位填补最左边的n位。也就是说如果数字院线是一个正数，则右移之后最左边补n个0；如果数字原先是负数，则右移之后是在最左边补n个1.
例：
00001010>>2 = 00000010
10001010>>3 = 11110001
    
**位运算的简单应用**

```
  功能              |           示例            |    位运算
———————-+—————————+——————–
去掉最后一位          | (101101->10110)           | x shr 1
在最后加一个0         | (101101->1011010)         | x shl 1
在最后加一个1         | (101101->1011011)         | x shl 1+1
把最后一位变成1       | (101100->101101)          | x or 1
把最后一位变成0       | (101101->101100)          | x or 1-1
最后一位取反          | (101101->101100)          | x xor 1
把右数第k位变成1      | (101001->101101,k=3)      | x or (1 shl (k-1))
把右数第k位变成0      | (101101->101001,k=3)      | x and not (1 shl (k-1))
右数第k位取反         | (101001->101101,k=3)      | x xor (1 shl (k-1))
取末三位              | (1101101->101)            | x and 7
取末k位               | (1101101->1101,k=5)       | x and (1 shl k-1)
取右数第k位           | (1101101->1,k=4)          | x shr (k-1) and 1
把末k位变成1          | (101001->101111,k=4)      | x or (1 shl k-1)
末k位取反             | (101001->100110,k=4)      | x xor (1 shl k-1)
把右边连续的1变成0    | (100101111->100100000)    | x and (x+1)
把右起第一个0变成1    | (100101111->100111111)    | x or (x+1)
把右边连续的0变成1    | (11011000->11011111)      | x or (x-1)
取右边连续的1         | (100101111->1111)         | (x xor (x+1)) shr 1
去掉右起第一个1的左边 | (100101000->1000)         | x and (x xor (x-1))
```
**c++代码**
```c++
#include<iostream>
#include<bitset>
using namespace std;

int main(){
	int a = 44;
	cout << "十进制:" << a << endl;
	cout << "十六进制:" << hex << a << endl;
	cout << "八进制:" << oct << a << endl;
	cout << "二进制:" << bitset<8>(a) << endl;
	cout << "去掉最后一位：" << bitset<8>(a >> 1) << endl;
	cout << "在最后加一个0：" << bitset<8>(a << 1) << endl;
	cout << "在最后加一个1：" << bitset<8>((a << 1) + 1) << endl;//左移、右移的优先级要小于加减法的优先级
	cout << "把最后一位变成1：" << bitset<8>(a | 1) << endl;
	cout << "提取最后一位：" << bitset<8>(a & 1) << endl;
	cout << "把最后一位变成0：" << bitset<8>((a | 1) - 1) << endl;
	cout << "把最后一位取反：" << bitset<8>(a ^ 1) << endl;
	int k = 4;
	cout << "把右数第" << k << "位变成1：" << bitset<8>(a | (1 << (k - 1))) << endl;
	cout << "把右数第" << k << "位变成0：" << bitset<8>((a | (1 << (k - 1)) )- 1)<<endl;
	cout << "把右数第" << k << "取反：" << bitset<8>(a ^(1<<(k-1))) << endl;
	cout << "取末位" << 3 << "位:" << bitset<8>(a & 7) << endl;
	cout << "取末位" << k << "位:" << bitset<8>(a & ((1<<k)-1)) << endl;
	cout << "取右数第" << k << "位:" << bitset<8>((a >> (k - 1)) & 1) << endl;	
	cout << "把末" << k << "位变成1：" << bitset<8>(a | ((1 << k) - 1)) << endl;
	cout << "把末" << k << "位按位取反：" << bitset<8>(a ^ ((1 << k) - 1)) << endl;
	cout << "把右边连续的1变成0：" << bitset<8>(a & (a + 1)) << endl;
	cout << "把右起第一个0变成1：" << bitset<8>(a | (a + 1)) << endl;
	cout << "把右边连续的0变成1：" << bitset<8>(a | (a - 1)) << endl;
	cout << "取右边连续的1:" << bitset<8>((a ^ (a + 1)) >> 1) << endl;
	cout << "去掉右起第一个1的左边：" << bitset<8>(a&(a ^ (a - 1))) << endl;
}
```
## 三、位运算进阶
转自[位运算简介及实用技巧（二）：进阶篇(1)](http://www.matrix67.com/blog/archives/264)

### **1、二进制中的1有奇数个还是偶数个** 

（1）、方法一：直接的思路：一位一位的求二进制中1的个数，然后确定是奇数还是偶数。
```
bool is_jishu(unsigned a){//常规解法，
	int c = 0;
	for (int i = 0; i < 32; i++){
		c = c + (a & 1);
		a = a >> 1;
	}
	return (c & 1);
}
```
(2)、改进的方法：每次利用a&(a-1)去掉最右边的1，直到a变成0，去掉了几次就代表a的二进制中含有几个1
```
bool is_jishu2(unsigned a){
	int c = 0;
	while (a){
		c++;
		a = a&(a - 1);
	}
	return (c & 1);
}
```
(3)、运用位运算，整个过程就是不断的压缩信息，先用1位代表从本位开始向左的2位中1的奇偶，然后向左的4位，向左的8位。。。。，经过5次位运算之后，结果就是32位整数所代表的1的个数的奇数偶数。
```
bool is_jishu(unsigned a){//用位运算进行求解
	unsigned x = a;
	x = x ^ (x >> 1);//计算原数中第i位和第i+1位中1的个数是奇数还是偶数，1代表奇数,也就是说，某个位为1，代表从它开始向左连续两位中1的个数是奇数（异或的本质）
	x = x ^ (x >> 2);//第二次异或，注意是两位两位的比较了，所有x是和x>>2做异或运算，比如，若结果第6位为1，那么代表上一次的结果的第6位和第8位有奇数个1，也就是原数中第6,7,8,9位中有奇数个1。
	x = x ^ (x >> 4);
	x = x ^ (x >> 8);
	x = x ^ (x >> 16);//同样，到第五次运算结束后，过第0位为1代表0到31位共奇数个1。
	return (x & 1);
}
```
第一次异或的结果，第i个位置上是1代表原数中第i位和第i+1位有一个为1，也就是奇数个1。也就是说，某个位为1，代表从它开始向左连续两位中1的个数是奇数（异或的本质）。
第二次异或，注意是两位两位的比较了，所有x是和x>>2做异或运算，比如，若结果第6位为1，那么代表上一次的结果的第6位和第8位有奇数个1，也就是原数中第6,7,8,9位中有奇数个1。
同样，到第五次运算结束后，过第0位为1代表0到31位共奇数个1。
整个过程就是不断的压缩信息，先用1位代表从本位开始向左的2位中1的奇偶，然后向左的4位，向左的8位。。。。

### **2、计算二进制中的1的个数**
（1）、方法一:注意到x&(x-1)可以去掉最右边的1，故可以每次利用a&(a-1)去掉最右边的1，直到a变成0，去掉了几次就代表a的二进制中含有几个1。
```
int count_one(unsigned a){
	int c = 0;
	while (a){
		c++;
		a = a&(a - 1);
	}
	return c;
}
```
(2)、以32位为例子:将n写成二进制形式，然后相邻位相加，重复这个过程，直到只剩下一位。以211为例，二进制为11010011，如下图：
![_config.yml]({{ site.baseurl }}/images/bit2.png)
 整个程序是一个**分治**的思想。第一次我们把每相邻的两位加起来，得到每两位里1的个数，比如前两位10就表示原数的前两位有2个1。第二次我们继续两两相加，10+01=11，00+10=10，得到的结果是00110010，它表示原数前4位有3个1，末4位有2个1。最后一次我们把0011和0010加起来，得到的就是整个二进制中1的个数。程序中巧妙地使用取位和右移，比如第二行中$33333333的二进制为00110011001100….，用它和x做and运算就相当于以2为单位间隔取数。**shr的作用就是让加法运算的相同数位对齐**。
```
int count_one2(unsigned a){
	a = ((a & 0x55555555) + ((a >> 1) & 0x55555555));//程序第一次运算，将每两位中1的数量加起来，存放在该两位中
	a = ((a & 0x33333333) + ((a >> 2) & 0x33333333));//第二次运算将每四位的中的1数量加起来，存放在该四位当中，依次类推
	a = ((a & 0x0f0f0f0f) + ((a >> 4) & 0x0f0f0f0f));
	a = ((a & 0x00ff00ff) + ((a >> 8) & 0x00ff00ff));
	a = ((a & 0x0000ffff) + ((a >> 16) & 0x0000ffff));
	return a;
}
```
## 四、参考

[位运算入门教程](https://www.jiuzhang.com/tutorial/bit-manipulation/72)

[位操作基础篇之位操作全面总结](http://blog.csdn.net/morewindows/article/details/7354571)

[位运算简介及实用技巧（三）：进阶篇(2)](http://blog.csdn.net/l290781453/article/details/21640665)

[计算机原码、反码、补码详解](http://blog.csdn.net/u011080472/article/details/51280919)


