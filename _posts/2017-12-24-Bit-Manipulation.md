---
layout: post
title: 位运算简介及使用技巧【转】
---

## 一、位运算基础
转自[位运算简介及实用技巧（一）：基础篇](http://www.matrix67.com/blog/archives/263)

**注意：** 一些值得注意的点

**1** 当进行位运算时，一个值得注意的概念是数值1并不是一个bit位，例如在32位int型中，1表示二进制表示为00000000 00000000 00000000 00000001.

**2** 注意左移<< 右移>> 的运算符优先级要低于加减法。

**3**  and(与)运算通常用于二进制取位操作，例如一个数 and 1的结果就是取二进制的最末位。这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数为偶数，最末位为1表示该数为奇数.

**4** or（或）运算通常用于二进制特定位上的无条件赋值，例如一个数or 1的结果就是把二进制最末位强行变成1。如果需要把二进制最末位变成0，对这个数or 1之后再减一就可以了，其实际意义就是把这个数强行变成最接近的偶数。

**5** xor运算通常用于对二进制的特定一位进行取反操作，因为异或可以这样定义：0和1异或0都不变，异或1则取反。
    xor运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即(a xor b) xor b = a。xor运算可以用于简单的加密。
    
**位运算的简单应用**

```
  功能              |           示例            |    位运算
———————-+—————————+——————–
去掉最后一位          | (101101->10110)           | x shr 1
在最后加一个0         | (101101->1011010)         | x shl 1
在最后加一个1         | (101101->1011011)         | x shl 1+1
把最后一位变成1       | (101100->101101)          | x or 1
把最后一位变成0       | (101101->101100)          | x or 1-1
最后一位取反          | (101101->101100)          | x xor 1
把右数第k位变成1      | (101001->101101,k=3)      | x or (1 shl (k-1))
把右数第k位变成0      | (101101->101001,k=3)      | x and not (1 shl (k-1))
右数第k位取反         | (101001->101101,k=3)      | x xor (1 shl (k-1))
取末三位              | (1101101->101)            | x and 7
取末k位               | (1101101->1101,k=5)       | x and (1 shl k-1)
取右数第k位           | (1101101->1,k=4)          | x shr (k-1) and 1
把末k位变成1          | (101001->101111,k=4)      | x or (1 shl k-1)
末k位取反             | (101001->100110,k=4)      | x xor (1 shl k-1)
把右边连续的1变成0    | (100101111->100100000)    | x and (x+1)
把右起第一个0变成1    | (100101111->100111111)    | x or (x+1)
把右边连续的0变成1    | (11011000->11011111)      | x or (x-1)
取右边连续的1         | (100101111->1111)         | (x xor (x+1)) shr 1
去掉右起第一个1的左边 | (100101000->1000)         | x and (x xor (x-1))
```
**c++代码**
```c++
#include<iostream>
#include<bitset>
using namespace std;

int main(){
	int a = 44;
	cout << "十进制:" << a << endl;
	cout << "十六进制:" << hex << a << endl;
	cout << "八进制:" << oct << a << endl;
	cout << "二进制:" << bitset<8>(a) << endl;
	cout << "去掉最后一位：" << bitset<8>(a >> 1) << endl;
	cout << "在最后加一个0：" << bitset<8>(a << 1) << endl;
	cout << "在最后加一个1：" << bitset<8>((a << 1) + 1) << endl;//左移、右移的优先级要小于加减法的优先级
	cout << "把最后一位变成1：" << bitset<8>(a | 1) << endl;
	cout << "提取最后一位：" << bitset<8>(a & 1) << endl;
	cout << "把最后一位变成0：" << bitset<8>((a | 1) - 1) << endl;
	cout << "把最后一位取反：" << bitset<8>(a ^ 1) << endl;
	int k = 4;
	cout << "把右数第" << k << "位变成1：" << bitset<8>(a | (1 << (k - 1))) << endl;
	cout << "把右数第" << k << "位变成0：" << bitset<8>((a | (1 << (k - 1)) )- 1)<<endl;
	cout << "把右数第" << k << "取反：" << bitset<8>(a ^(1<<(k-1))) << endl;
	cout << "取末位" << 3 << "位:" << bitset<8>(a & 7) << endl;
	cout << "取末位" << k << "位:" << bitset<8>(a & ((1<<k)-1)) << endl;
	cout << "取右数第" << k << "位:" << bitset<8>((a >> (k - 1)) & 1) << endl;	
	cout << "把末" << k << "位变成1：" << bitset<8>(a | ((1 << k) - 1)) << endl;
	cout << "把末" << k << "位按位取反：" << bitset<8>(a ^ ((1 << k) - 1)) << endl;
	cout << "把右边连续的1变成0：" << bitset<8>(a & (a + 1)) << endl;
	cout << "把右起第一个0变成1：" << bitset<8>(a | (a + 1)) << endl;
	cout << "把右边连续的0变成1：" << bitset<8>(a | (a - 1)) << endl;
	cout << "取右边连续的1:" << bitset<8>((a ^ (a + 1)) >> 1) << endl;
	cout << "去掉右起第一个1的左边：" << bitset<8>(a&(a ^ (a - 1))) << endl;
}
```
## 二、位运算进阶
转自[位运算简介及实用技巧（二）：进阶篇(1)](http://www.matrix67.com/blog/archives/264)

**1、二进制中的1有奇数个还是偶数个** 

（1）、方法一：直接的思路：一位一位的求二进制中1的个数，然后确定是奇数还是偶数。
```
bool is_jishu(unsigned a){//常规解法，
	int c = 0;
	for (int i = 0; i < 32; i++){
		c = c + (a & 1);
		a = a >> 1;
	}
	return (c & 1);
}
```
(2)、改进的方法：每次利用a&(a-1)去掉最右边的1，直到a变成0，去掉了几次就代表a的二进制中含有几个1
```
bool is_jishu2(unsigned a){
	int c = 0;
	while (a){
		c++;
		a = a&(a - 1);
	}
	return (c & 1);
}
```
(3)、运用位运算，整个过程就是不断的压缩信息，先用1位代表从本位开始向左的2位中1的奇偶，然后向左的4位，向左的8位。。。。，经过5次位运算之后，结果就是32位整数所代表的1的个数的奇数偶数。
```
bool is_jishu(unsigned a){//用位运算进行求解
	unsigned x = a;
	x = x ^ (x >> 1);//计算原数中第i位和第i+1位中1的个数是奇数还是偶数，1代表奇数,也就是说，某个位为1，代表从它开始向左连续两位中1的个数是奇数（异或的本质）
	x = x ^ (x >> 2);//第二次异或，注意是两位两位的比较了，所有x是和x>>2做异或运算，比如，若结果第6位为1，那么代表上一次的结果的第6位和第8位有奇数个1，也就是原数中第6,7,8,9位中有奇数个1。
	x = x ^ (x >> 4);
	x = x ^ (x >> 8);
	x = x ^ (x >> 16);//同样，到第五次运算结束后，过第0位为1代表0到31位共奇数个1。
	return (x & 1);
}
```
第一次异或的结果，第i个位置上是1代表原数中第i位和第i+1位有一个为1，也就是奇数个1。也就是说，某个位为1，代表从它开始向左连续两位中1的个数是奇数（异或的本质）。
第二次异或，注意是两位两位的比较了，所有x是和x>>2做异或运算，比如，若结果第6位为1，那么代表上一次的结果的第6位和第8位有奇数个1，也就是原数中第6,7,8,9位中有奇数个1。
同样，到第五次运算结束后，过第0位为1代表0到31位共奇数个1。
整个过程就是不断的压缩信息，先用1位代表从本位开始向左的2位中1的奇偶，然后向左的4位，向左的8位。。。。

**2、计算二进制中的1的个数**
（1）、方法一:注意到x&(x-1)可以去掉最右边的1，故可以每次利用a&(a-1)去掉最右边的1，直到a变成0，去掉了几次就代表a的二进制中含有几个1。
```
int count_one(unsigned a){
	int c = 0;
	while (a){
		c++;
		a = a&(a - 1);
	}
	return c;
}
```
(2)、以32位为例子:将n写成二进制形式，然后相邻位相加，重复这个过程，直到只剩下一位。以211为例，二进制为11010011，如下图：
![_config.yml]({{ site.baseurl }}/images/bit2.png)
 整个程序是一个**分治**的思想。第一次我们把每相邻的两位加起来，得到每两位里1的个数，比如前两位10就表示原数的前两位有2个1。第二次我们继续两两相加，10+01=11，00+10=10，得到的结果是00110010，它表示原数前4位有3个1，末4位有2个1。最后一次我们把0011和0010加起来，得到的就是整个二进制中1的个数。程序中巧妙地使用取位和右移，比如第二行中$33333333的二进制为00110011001100….，用它和x做and运算就相当于以2为单位间隔取数。**shr的作用就是让加法运算的相同数位对齐**。
```
int count_one2(unsigned a){
	a = ((a & 0x55555555) + ((a >> 1) & 0x55555555));//程序第一次运算，将每两位中1的数量加起来，存放在该两位中
	a = ((a & 0x33333333) + ((a >> 2) & 0x33333333));//第二次运算将每四位的中的1数量加起来，存放在该四位当中，依次类推
	a = ((a & 0x0f0f0f0f) + ((a >> 4) & 0x0f0f0f0f));
	a = ((a & 0x00ff00ff) + ((a >> 8) & 0x00ff00ff));
	a = ((a & 0x0000ffff) + ((a >> 16) & 0x0000ffff));
	return a;
}
```
