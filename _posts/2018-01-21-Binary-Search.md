---
layout: post
title: 基础算法之二分查找
---

## 1、二分查找总结
### 1.版本A——三分支，查找失败时返回-1
**注：** 以下都采用左闭右开区间

![binarySearch1]({{ site.baseurl }}/images/binarySearch.png)

以任一元素S[mi]=x为界，都可以将该区间分为三个部分，且根据此时向量的有序性必有：
S[lo,mi)<=S[mi]<=S[mi+1,hi）
于是，只需将目标元素e与x做一比较，即可根据比较结果分为以下三种情况进行进一步处理：
1 ) 若 e <x， 则目标元素如果存在 ， 必属于左侧于区间S[lo,mi)，故可深入其中继续查找； 2) 若 x < e ， 则目标元素如果存在 ，必属于右侧于区间 S[mi+1,hi） ，故也可深入其间继续在找 3 ) 若 e== x ， 则意味着已经命中，故查找随即终止。
也就是说，每经过至多两次的比较，我们或者已经找到目标元素，或者可以将查找问题简化为一个规模更小的新问题。以下介绍的查找算法都可以归于这一模式，不同点仅在于其对于切分点mi的选取策略，以及每次深入 递归之前所做的比较次数。

#### 实现

```c++
/*
*查找区间为[lo,hi)
*每次迭代可能要做两次比较，有三个分支
*成功查找可以提前终止
*在有多个命中元素命中的时候，不能保证返回最靠后者
*在查找失败时，简单的返回-1，而不能指示查找失败的位置
*/
int binarySearch(vector<int> vecs, int value){//版本A，三分支,查找成功时返回下标，失败时返回-1,
		int lo = 0, hi = vecs.size();
		while (lo < hi){
			int mi = (lo + hi) >> 1;//右移运算比除法运算速度要快
			if (value < vecs[mi])
				hi = mi;
			else if (vecs[mi] < value)
				lo = mi + 1;
			else
				return mi;
		}
		return -1;
	}
```

#### 复杂度
O(log(n))

#### 查找长度
在上述的二分查找算法中，迭代过程涉及的计算主要包括元素大小的比对，秩的运算及赋值，相对复杂度的常系数而言，元素的比较操作的权重往往更大，复杂对象的比较操作往往非常耗时。因此，对查找算法性能更为精细的评估，应更多地关注算法过程中关键码的比较次数，即查找长度（search length）。通常需分别针对成功和失败查找。

在上述的三分支查找算法中，在每次迭代中，为确定左右分支方向而需要做得比较次数分别是1、2.由此造成了不同情况所对应的查找长度的不均性。尽管该版本从表面上看完全均衡，但分析可知最长和最短分支所对应的查找长度相差两倍，这也从一个侧面印证了该算法实际的不均衡性。

具体改进的方法：
1.Fibonacci查找：mi不选择中点，而是选择中点偏后的Fibonacci项。

2.将三分支改成两分支，

### 2.版本B——两分支，查找失败时返回-1
**注：** 以下都采用左闭右开区间

无论朝哪个方向深入 ， 都只需做 1 次元茸的大小比较。相应地 ， ;):法
在每次选代中(或递归层次上)币ífl只有两个分立方向iJ ，而不再是三个 。

![binarySearch2]({{ site.baseurl }}/images/binarySearch2.png)

具体过程类似于版本A，在每个切分点mi处，仅做一次比较。若e<A[mi]，则深入A[lo,mi)继续查找，否则，深入A[mi,hi)继续查找。

#### 实现


```c++
/*
*查找区间为[lo,hi)
*每次迭代仅需做一次比较，有两个分支
*成功查找不会提前终止
*在有多个命中元素时，不会返回最靠后的
*查找失败时，简单的返回-1，不能指示失败的位置
*因为终止条件是区间中只有一个元素，所以当输入为空时，需要单独判断
*/
int binarySearch2(vector<int> vecs, int value){//两分支，
		if (vecs.empty())
			return -1;
		int lo = 0, hi = vecs.size();
		while (1 < hi - lo){
			int mi = (hi + lo) >> 1;
			if (value < vecs[mi])
				hi = mi;
			else
				lo = mi;			
		}
		return (value == vecs[lo] ? lo : -1);
	}
```
### 3.版本C——两分支，能返回查找失败的位置
**注：** 以下都采用左闭右开区间
在版本B的基础上略做修改，可以得到版本C

```c++
/*
*查找区间为[lo,hi)
*每次迭代仅需一次比较，有两个分支
*成功查找不能提前终止
*在有多个命中元素时，总能保证返回最靠后者
*在查找失败时，能够返回失败的位置
*/

int binarySearch3(vector<int> vecs, int value){
		int lo = 0, hi = vecs.size();
		while (lo < hi){
			int mi = (hi + lo) >> 1;
			if (value < vecs[mi])
				hi = mi;
			else
				lo = mi + 1;
		}
		return --lo;
	}
```

#### 正确性
从形式上看，版本C与版本B的差异主要有三点。首先，只有当向量额区间宽度缩小到0（而不是1）时，迭代算法才终止。另外，在每次转入后端分支时，子向量的左边界取做mi+1,（而不是mi）。从表面上看，后一调整可能存在错误的风险——此时只能确定切分点A[mi]<=e，而贸然将A[mi]排除在进一步的查找范围之外，似乎会因遗漏目标元素而导致本应该成功的查找以失败告终。然而这种担心大可不必。
以下验证其正确性。
为确定版本c的正确性，不妨考察该算法中的循环体中的如下不变性：如图所示，A[0,lo)中的元素皆不大于e，A[hi,n)中的元素皆大于e。首次进入该循环时，lo=0且hi=n，A[0,lo),A[hi,n)均为空，不变性自然成立。以下数学归纳：如图a所示，假设某次进入该循环时，以上的不变性成立。根据算法的流程无非两种情况。若e<A[mi],如图b所示，在令hi=mi并使A[hi,n)向左扩展之后，该区间内的元素皆不小于A[mi],当然也仍然大于e。反之，若A[mi]<=e,如图c所示，在令lo=mi+1并使A[0,lo)向右扩展之后，该区间内的元素皆不大于A[mi]，当然仍然不大于e。总之无论如何，每次循环之后上述不变性仍然得以延续。

![binarySearch3]({{ site.baseurl }}/images/binarySearch2.png)

循环终止时，lo=hi。考察此时的元素A[lo-1]和A[lo]:最为A[0,lo)内的最后一个元素，A[lo-1]必定不大于e；作为A[lo,n)内的第一个元素，A[lo]必定大于e，也就是说A[lo-1]即是原向量中不大于e的最后一个元素。因此，在循环结束后，无论成功与否，只需要返回lo-1即可。


##  参考






