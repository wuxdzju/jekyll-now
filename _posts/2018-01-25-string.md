---
layout: post
title: 字符串及串匹配
---

标签：字符串 串 

[TOC]

##  一、C风格字符串

### 1、什么是C风格字符串
C风格字符串是c++从c语言中继承而来的，实际上，c风格字符串既不能确切地归结为c语言的类型，还是归结为c++语言的类型。**而是以空字符null结束的字符数组。**
字符串字面值（例如  “hello world”)就是该类型的实例，字符串字面值的类型是const char类型的数组，并且以'\0'结尾。
另外，
char cal[]={'C','C','\0'};
cal也是一个c风格字符串，因为其以'\0'结尾的字符数组。
而
char cal2[]={'c','c'};
cal2就不是c风格字符串。

### 2、C风格字符串的标准库函数
在c++中使用该函数库应该包括的头文件 #include<ctring>

|函数|说明|
|-----|
|strlen(s)  |返回s的长度，不包括字符串结束符null|
|strcmp(s1,s2)|比较两个字符串s1和s2是否相同。若s1与s2相等，则返回0；若s1大于s2，返回正数；若s1小于s2，返回负数|
|strcat(s1,s2)|将字符串s2连接到s1后，并返回s1|
|strcpy(s1,s2)|将s2复制给s1，并返回s1|
|strncat(s1,s2,n)|将s2的n个字符连接到s1后面，并返回s1|
|strncpy(s1,s2,n)|将s2的前n字符复制给s1，并返回s1|


```c++
void test(){
	char *a="hello",*b="world";	
	cout << strlen(a) << endl;
	cout<<strcmp(a, b)<<endl;
	char large[20];
	strcpy(large, a);
	cout << strncat(large, b,3) << endl;
}
```

### 3、使用C风格字符串应注意的几点
1）在使用c风格字符串的标准库函数中，**传递给这些标准库函数的指针必须具有非零值，并且指向以null结束的字符串数组中的第一个元素**。

2）**永远不要忘记字符串结束符结束符null。**
c风格字符串标准函数库中的函数总是假定其参数字符串是以null字符结束，若传递的参数不是以null结尾的话，可能会发生不可预知的错误。

3）调用者必须保证目标字符串具有足够的大小。
**传递给strcat和strcpy的第一个实参数组必须具有足够大的空间存放新生成的字符串。**

4）如果必须使用c风格字符串标准库函数，推荐使用strncat、strncpy函数处理
**使用标准库函数strncat、strncpy比使用strcat和strcpy函数要更安全。**因为前者可以适当地控制字符个数。


##  二、C++中的string类


## 三、字符串匹配

【参考】[http://blog.csdn.net/u011467044/article/details/55008649](http://blog.csdn.net/u011467044/article/details/55008649)

### 1、字符串匹配问题描述
在文本编辑程序中，经常出现要在一段文本中找出某个模式的全部出现位置这一问题，这个模式字符串即为用户查找输入的关键字，解决这个问题的方法就是字符串匹配算法。

![字符串匹配问题描述string1.png]({{ site.baseurl }}/images/string1.png)

常用的一些算法即时间复杂度如下表所示：

![字符串匹配时间复杂度string2.png]({{ site.baseurl }}/images/string2.png)

### 2、朴素的字符串匹配算法

我们用两个游标i，j分别指向文本串T与模式串P中当前考察字符的位置，有
a）当匹配到T[i]==P[j]时，i++，j++
b）当匹配到某一位置时，出现T[i]!=P[j]，即匹配失败，i回溯至本次匹配开始位置，并向后移一格，而j=0.

代码实现如下：

```c++
int naiveMatch(char *T, char *P){//朴素的字符串匹配算法，返回匹配成功时在T中的位置，当返回值为n-m+1时，表示匹配失败
	//获取原串和模式串的长度
	int n = strlen(T), s=0;
	int m = strlen(P), j=0;
	for (s = 0; s < n - m + 1; s++){//模式串从0至n-m偏移
		for (j = 0; j < m; j++){//模式串从0至m-1逐个与原串中的字符匹配，看是否相等，
			if (T[s+j] != P[j])//如果在匹配过程中如果不相等，则跳出该循环，偏移s右移一位，重新开始匹配
				break;			//注意这里用的是s+j，匹配过程中并没改变s的值，
		}
		if (j == m) break;//若模式串中的所有字符皆与原串中字符匹配，即匹配成功，跳出循环
		
	}
	return s;//返回查找成功时的偏移s，当s>n-m时，表示查找失败
}
```

查找实例如下：

![字符串匹配时间复杂度string2.png]({{ site.baseurl }}/images/string3.png)

**注：假设模式P中的所有字符都是不同的。则可以改进上述naiveMatch算法，使其对一段n个字符的文本T的处理过程加速到O(n)。**

加速的过程是：当匹配失败时，s可以直接跳到失败的位置。因为从初始位置到失败位置中间的与P中的对应字符，而P中的字符都互不相同，P向后移一位时，之前能匹配上的字符必定不能匹配成功，故可以直接跳过。

![字符串匹配时间复杂度string4.png]({{ site.baseurl }}/images/string4.png)

代码实现如下所示：

```c++
int naiveMatchSpecial(char *T, char *P){//当P中的字符都不相同时，可以改进naiveMatch算法，使匹配时间到达O(N)
	int n = strlen(T),s=0;
	int m = strlen(P), j = 0;
	for (s = 0; s < n - m + 1; s++){
		for (j = 0; j < m; j++){
			if (T[s+j] != P[j]){
				break;
			}					
		}
		if (j == m)
			break;
		else
			s += j;//当匹配失败时，s可以直接跳到失败的位置
	}
	return s;
}
```

### 2、Rabin-Karp算法
该算法的思想是将长度为k的字符转换为长度为k的d进制数字。然后将字符串的比较转换为数值的比较。

为了便于说明，我们假定字母表为{0,1,2，……，9}，这样的每个字符都是十进制数字（一般情况下，可以假定每个字符都是基数为d的表示法中的一个数字）。可以用一个长度为k的十进制数来表示由k个连续字符组成的字符串。
如果我们用O(m)的时间计算出模式串的数值p，并用O(n-m+1)的时间内计算出所有长度与P相同的子串T（s+1,……，s+m)的所有数值ts的值，那么，通过把p值与每个ts值进行比较，就能够在O(m)+O(n-m+1)的时间内，求出所有有效移位s。

我们可以运用霍纳法则在O(m)的时间内计算出p的值。

![字符串匹配时间复杂度string5.png]({{ site.baseurl }}/images/string5.png)

类似的，也可以在O(m)的时间内计算出t0的值，为了在O(n-m)的时间内计算出剩余t1，t2，……，的值，可以在常数的时间内根据ts计算出t（s+1），

![字符串匹配时间复杂度string6.png]({{ site.baseurl }}/images/string6.png)




## 参考
[算法导论-字符串匹配](http://blog.csdn.net/u011467044/article/details/55008649)